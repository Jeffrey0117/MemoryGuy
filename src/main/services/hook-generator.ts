import path from 'path';
import fs from 'fs';
import os from 'os';
import type { ProtectionStore } from './protection-store';

const HOOK_FILENAME = 'block-process-kill.js';

export class HookGenerator {
  constructor(private protectionStore: ProtectionStore) {}

  generate(): { success: boolean; path?: string; error?: string } {
    try {
      const rules = this.protectionStore.getRules();
      const protectedPatterns = rules
        .filter((r) => r.enabled && r.mode === 'protect' && !r.builtIn)
        .map((r) => r.pattern.replace('.exe', ''));

      if (protectedPatterns.length === 0) {
        return { success: false, error: 'No custom protection rules with mode "protect" found' };
      }

      const hooksDir = path.join(os.homedir(), '.claude', 'hooks');
      const hookPath = path.join(hooksDir, HOOK_FILENAME);
      const settingsPath = path.join(os.homedir(), '.claude', 'settings.json');

      // Ensure hooks directory exists
      if (!fs.existsSync(hooksDir)) {
        fs.mkdirSync(hooksDir, { recursive: true });
      }

      // Generate the hook script
      const regexParts = protectedPatterns.map((p) =>
        p.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
      );
      const hookScript = this.buildHookScript(regexParts);
      fs.writeFileSync(hookPath, hookScript, 'utf-8');

      // Register in settings.json
      this.registerHook(settingsPath, hookPath);

      return { success: true, path: hookPath };
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      return { success: false, error: message };
    }
  }

  private buildHookScript(patterns: string[]): string {
    const regex = patterns.join('|');
    const safeComment = patterns.map((p) => p.replace(/[^\w.\-]/g, '_')).join(', ');
    return `// Generated by MemoryGuy - blocks dangerous process kill commands
// Protected processes: ${safeComment}
const PROTECTED_RE = /(taskkill|Stop-Process|kill|pkill|killall).*?(${regex})/i;
const PID_KILL_RE = /taskkill.*?\\/F.*?\\/IM\\s+(${regex})/i;

function checkCommand(input) {
  if (!input || typeof input !== 'string') return;
  if (PROTECTED_RE.test(input) || PID_KILL_RE.test(input)) {
    console.error(\`BLOCKED: Command targets a protected process. Use MemoryGuy to manage protected processes.\`);
    process.exit(2);
  }
}

// Read from stdin (Claude Code hook protocol)
let data = '';
process.stdin.setEncoding('utf-8');
process.stdin.on('data', (chunk) => { data += chunk; });
process.stdin.on('end', () => {
  try {
    const payload = JSON.parse(data);
    const command = payload?.tool_input?.command || '';
    checkCommand(command);
  } catch {
    // Not JSON or no command â€” allow
  }
});
`;
  }

  private registerHook(settingsPath: string, hookPath: string): void {
    let settings: Record<string, unknown> = {};

    try {
      if (fs.existsSync(settingsPath)) {
        settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
      }
    } catch {
      settings = {};
    }

    const hooks = (settings.hooks ?? {}) as Record<string, unknown>;
    const preToolUse = (hooks.PreToolUse ?? []) as Array<Record<string, unknown>>;

    // Check if already registered
    const normalizedPath = hookPath.replace(/\\/g, '/');
    const alreadyRegistered = preToolUse.some((h) => {
      const cmd = String(h.command ?? '');
      return cmd.includes(HOOK_FILENAME) || cmd.includes(normalizedPath);
    });

    if (!alreadyRegistered) {
      const hookEntry = {
        matcher: 'Bash',
        command: `node "${normalizedPath}"`,
      };
      const updatedPreToolUse = [...preToolUse, hookEntry];
      const updatedHooks = { ...hooks, PreToolUse: updatedPreToolUse };
      const updatedSettings = { ...settings, hooks: updatedHooks };

      const dir = path.dirname(settingsPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      fs.writeFileSync(settingsPath, JSON.stringify(updatedSettings, null, 2), 'utf-8');
    }
  }
}
